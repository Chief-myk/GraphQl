// src/services/user.ts
import { createHmac, randomBytes } from "crypto";
import { prismaClient } from "../lib/db.js";
import jwt from "jsonwebtoken";

// Always keep secrets in .env (never hardcode in code)
const JWT_SECRET = process.env.JWT_SECRET || "SUPER_SECRET_KEY";

export interface UserPayload {
  id?: string; // id is generated by DB, so optional
  email: string;
  firstname: string;
  lastname?: string;
  password: string;
  profileImageUrl?: string;
}

export interface GetUserTokenPayload {
  email: string;
  password: string;
}

class UserService {
  // üîë helper for hashing
  private static createHash(password: string, salt: string): string {
    return createHmac("sha256", salt)
      .update(password)
      .digest("hex");
  }

  // üë§ Create user
  public static async createUser(payload: UserPayload) {
    const { email, firstname, lastname, password, profileImageUrl } = payload;

    // generate secure salt
    const salt = randomBytes(16).toString("hex");

    // hash password with salt
    const hash = UserService.createHash(password, salt);

    // save user
    return prismaClient.user.create({
      data: {
        email,
        firstname,
        lastname: lastname ?? null,
        password: hash,
        salt,
        profileImageUrl: profileImageUrl ?? null
      }
    });
  }

  // üîê Login and return JWT
  public static async getUserToken(payload: GetUserTokenPayload) {
    const { email, password } = payload;

    // find user by email
    const user = await prismaClient.user.findUnique({
      where: { email }
    });

    if (!user) throw new Error("User not found");

    // hash provided password with stored salt
    const hash = UserService.createHash(password, user.salt);

    if (hash !== user.password) {
      throw new Error("Invalid password");
    }

    // generate JWT
    const token = jwt.sign(
      {
        email: user.email,
        id: user.id
      },
      JWT_SECRET,
      { expiresIn: "1h" }
    );

    return token;
  }
}

export default UserService;
